/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

import {assert} from '@webex/test-helper-chai';
import MockWebex from '@webex/test-helper-mock-webex';
import Services from '@webex/internal-plugin-services';

/* eslint-disable no-underscore-dangle */
describe('plugin-services', () => {
  describe('Service', () => {
    let webex;
    let services;

    let serviceList;
    let promise;

    beforeEach('initialize webex', () => {
      webex = new MockWebex({
        children: {
          services: Services
        }
      });
      services = webex.internal.services;
    });

    describe('#namespace', () => {
      it('is accurate to plugin name', () => {
        assert.equal(services.namespace, 'Services');
      });
    });

    describe('#status', () => {
      it('has all the required keys', () => {
        assert.hasAllKeys(services.status, ['ready']);
      });

      it('has valid key value types', () => {
        assert.typeOf(services.status.ready, 'boolean');
      });

      it('has valid key values', () => {
        assert.isNotTrue(services.status.ready);
      });
    });

    describe('#_serviceUrls', () => {
      it('must be of type array', () => {
        assert.typeOf(services._serviceUrls, 'array');
      });
    });

    describe('#_serviceUrlsLimited', () => {
      it('must be of type array', () => {
        assert.typeOf(services._serviceUrlsLimited, 'array');
      });
    });

    describe('#_serviceUrlsDiscovery', () => {
      it('must be of type array', () => {
        assert.typeOf(services._serviceUrlsDiscovery, 'array');
      });

      it('must contain at least one url', () => {
        assert.isAbove(services._serviceUrlsDiscovery.length, 0);
      });
    });

    describe('#services()', () => {
      beforeEach('get service list', () => {
        serviceList = services.services();
      });

      it('must return an object', () => {
        assert.typeOf(serviceList, 'object');
      });

      it('returned list must be of shape {Record<string, string>}', () => {
        Object.keys(serviceList).forEach((key) => {
          assert.typeOf(serviceList[key], 'string');
        });
      });
    });

    describe('#waitUntilReady()', () => {
      beforeEach('get return value', () => {
        promise = services.waitUntilReady();
      });

      it('returns a promise', () => {
        assert.typeOf(promise, 'promise');
      });

      it('doesn\'t resolve until services plugin is ready', () => {
        promise.then(() => {
          assert.equal(services.status.ready, true);
        });
      });

      it('returns a resolved promise if services is already ready', () => {
        promise.then(() => services.waitUntilReady).then(() => {
          assert.equal(services.status.ready, true);
        });
      });
    });

    describe('#_formatReceivedHostmap()', () => {
      let serviceHostmap;
      let formattedHM;

      beforeEach(() => {
        serviceHostmap = {
          serviceLinks: {
            'example-a': 'https://example-a.com/api/v1',
            'example-b': 'https://example-b.com/api/v1',
            'example-c': 'https://example-c.com/api/v1'
          },
          hostCatalog: {
            'example-a.com': [
              {host: 'example-a-1.com', ttl: -1, priority: 5},
              {host: 'example-a-2.com', ttl: -1, priority: 3},
              {host: 'example-a-3.com', ttl: -1, priority: 1}
            ],
            'example-b.com': [
              {host: 'example-b-1.com', ttl: -1, priority: 5},
              {host: 'example-b-2.com', ttl: -1, priority: 3},
              {host: 'example-b-3.com', ttl: -1, priority: 1}
            ],
            'example-c.com': [
              {host: 'example-c-1.com', ttl: -1, priority: 5},
              {host: 'example-c-2.com', ttl: -1, priority: 3},
              {host: 'example-c-3.com', ttl: -1, priority: 1}
            ]
          },
          format: 'hostmap'
        };
        formattedHM = services._formatReceivedHostmap(serviceHostmap);
      });

      it('creates an array of equal length of serviceLinks', () => {
        assert.equal(Object.keys(serviceHostmap.serviceLinks).length,
          formattedHM.length);
      });

      it('creates an array of equal length of hostMap', () => {
        assert.equal(Object.keys(serviceHostmap.hostCatalog).length,
          formattedHM.length);
      });

      it('creates an array with matching url data', () => {
        formattedHM.forEach((entry) => {
          assert.equal(serviceHostmap.serviceLinks[entry.name],
            entry.defaultUrl);
        });
      });

      it('creates an array with matching host data', () => {
        let foundFormatted;

        Object.keys(serviceHostmap.hostCatalog).forEach((key) => {
          foundFormatted = formattedHM.find(
            (entry) => entry.defaultUrl.includes(key)
          );

          assert.equal(foundFormatted.hosts, serviceHostmap.hostCatalog[key]);
        });
      });

      it('creates an array with matching names', () => {
        assert.hasAllKeys(serviceHostmap.serviceLinks,
          formattedHM.map((item) => item.name));
      });
    });
  });
});
/* eslint-enable no-underscore-dangle */
