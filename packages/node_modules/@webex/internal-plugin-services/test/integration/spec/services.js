/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

import '@webex/internal-plugin-wdm';
import '@webex/internal-plugin-services';

import {assert} from '@webex/test-helper-chai';
import sinon from 'sinon';
import WebexCore from '@webex/webex-core';
import testUsers from '@webex/test-helper-test-users';
import ServiceUrl from '@webex/internal-plugin-services/src/service-url';

/* eslint-disable no-underscore-dangle */
describe('plugin-services', () => {
  describe('Services', () => {
    let webexUser;
    let webex;
    let services;

    before('create users', () => testUsers.create({count: 1})
      .then(([user]) => new Promise((resolve) => {
        setTimeout(() => {
          webexUser = user;
          webex = new WebexCore({credentials: {supertoken: user.token}});
          services = webex.internal.services;
          resolve();
        }, 3000);
      }))
      .then(() => webex.internal.device.register())
      .then(() => services.updateServices())
      .then(() => services.waitUntilReady())
      .then(() => services.updateServices('userId', webexUser.id)));

    describe('#status', () => {
      it('updates ready when services ready', () => {
        assert.equal(services.status.ready, true);
      });
    });

    describe('#_serviceUrls', () => {
      it('contains more services than _serviceUrlsDiscovery', () => {
        assert.isAbove(services._serviceUrls.length,
          services._serviceUrlsDiscovery.length);
      });

      it('contains more services than _serviceUrlsLimited', () => {
        assert.isAbove(services._serviceUrls.length,
          services._serviceUrlsLimited.length);
      });
    });

    describe('#_serviceUrlsLimited', () => {
      it('contains less services than _serviceUrls', () => {
        assert.isBelow(services._serviceUrlsLimited.length,
          services._serviceUrls.length);
      });

      it('contains more services than _serviceUrlsDiscovery', () => {
        assert.isAbove(services._serviceUrlsLimited.length,
          services._serviceUrlsDiscovery.length);
      });
    });

    describe('#_serviceUrlsDiscovery', () => {
      it('contains less services than _serviceUrls', () => {
        assert.isBelow(services._serviceUrlsDiscovery.length,
          services._serviceUrls.length);
      });

      it('contains more services than _serviceUrlsLimited', () => {
        assert.isBelow(services._serviceUrlsDiscovery.length,
          services._serviceUrlsLimited.length);
      });
    });

    describe('#_generateServicesList()', () => {
      it('returns an object of shape Record<string, string>', () => {
        const serviceList = services._generateServicesList();

        Object.keys(serviceList).forEach((key) => {
          assert.typeOf(key, 'string');
          assert.typeOf(serviceList[key], 'string');
        });
      });

      it('retreives priority host urls base on priorityHost parameter', () => {
        const serviceList = services._generateServicesList(true);

        const foundPriorityValues = services._serviceUrls.some(
          (serviceUrl) => serviceUrl.hosts.some(
            ({host}) => Object.keys(serviceList).some(
              (key) => serviceList[key].includes(host)
            )
          )
        );

        assert.isTrue(foundPriorityValues);
      });

      it('returns an object of based on serviceGroup parameter', () => {
        let serviceList = services._generateServicesList(true, 'Discovery');

        assert.equal(Object.keys(serviceList).length,
          services._serviceUrlsDiscovery.length);

        serviceList = services._generateServicesList(true, 'Limited');

        assert.equal(Object.keys(serviceList).length,
          services._serviceUrlsLimited.length);

        serviceList = services._generateServicesList();

        assert.isAtLeast(Object.keys(serviceList).length,
          services._serviceUrls.length);
      });
    });

    describe('#services()', () => {
      it('returns list matches values in serviceUrl', () => {
        let serviceList = services.services();

        Object.keys(serviceList).forEach((key) => {
          assert.equal(serviceList[key], services._getUrl(key).get());
        });

        serviceList = services.services(true);
        Object.keys(serviceList).forEach((key) => {
          assert.equal(serviceList[key], services._getUrl(key).get(true));
        });
      });

      it('calls _generateServicesList with all params when provided', () => {
        sinon.spy(services, '_generateServicesList');

        services.services(true, 'Limited');

        assert.isTrue(services._generateServicesList
          .calledWith(true, 'Limited'));
      });
    });

    describe('#_getUrl()', () => {
      let testUrlTemplate;
      let testUrl;

      beforeEach('load test url', () => {
        testUrlTemplate = {
          defaultUrl: 'https://www.example.com/api/v1',
          hosts: [],
          name: 'exampleValid'
        };
        testUrl = new ServiceUrl({...testUrlTemplate});
        services._loadServiceUrls('Limited', [testUrl]);
      });

      it('returns a ServiceUrl from a specific serviceGroup', () => {
        const serviceUrl = services._getUrl(testUrlTemplate.name, 'Limited');

        assert.equal(serviceUrl.defaultUrl, testUrlTemplate.defaultUrl);
        assert.equal(serviceUrl.hosts, testUrlTemplate.hosts);
        assert.equal(serviceUrl.name, testUrlTemplate.name);
      });

      it('returns undefined if url doesn\'t exist', () => {
        const serviceUrl = services._getUrl('invalidUrl');

        assert.typeOf(serviceUrl, 'undefined');
      });

      it('returns undefined if url doesn\'t exist in serviceGroup', () => {
        const serviceUrl = services._getUrl(testUrlTemplate.name, 'Discovery');

        assert.typeOf(serviceUrl, 'undefined');
      });

      afterEach('unload test url', () => {
        services._unloadServiceUrls('Limited', [testUrl]);
      });
    });

    describe('#get()', () => {
      let testUrlTemplate;
      let testUrl;

      beforeEach('load test url', () => {
        testUrlTemplate = {
          defaultUrl: 'https://www.example.com/api/v1',
          hosts: [],
          name: 'exampleValid'
        };
        testUrl = new ServiceUrl({...testUrlTemplate});
        services._loadServiceUrls('Limited', [testUrl]);
      });

      it('returns a valid string when name is specified', () => {
        const url = services.get(testUrlTemplate.name);

        assert.typeOf(url, 'string');
        assert.equal(url, testUrlTemplate.defaultUrl);
      });

      it('returns undefined if url doesn\'t exist', () => {
        const s = services.get('invalidUrl');

        assert.typeOf(s, 'undefined');
      });

      it('calls _getUrl', () => {
        sinon.spy(services, '_getUrl');

        services.get();

        assert.called(services._getUrl);
      });

      it('gets a service from a specific serviceGroup', () => {
        assert.isDefined(services.get(testUrlTemplate.name, false, 'Limited'));
      });

      it('fails to get a service if serviceGroup isn\'t accurate', () => {
        assert.isUndefined(services.get(testUrlTemplate.name,
          false, 'Discovery'));
      });

      afterEach('unload test url', () => {
        services._unloadServiceUrls('Limited', [testUrl]);
      });
    });

    describe('#markFailedUrl()', () => {
      let testUrlTemplate;
      let testUrl;

      beforeEach('load test url', () => {
        testUrlTemplate = {
          defaultUrl: 'https://www.example.com/api/v1',
          hosts: [
            {
              host: 'www.example-p5.com',
              ttl: -1,
              priority: 5
            },
            {
              host: 'www.example-p3.com',
              ttl: -1,
              priority: 3
            }
          ],
          name: 'exampleValid'
        };
        testUrl = new ServiceUrl({...testUrlTemplate});
        services._loadServiceUrls('Limited', [testUrl]);
      });

      it('marks a host as failed and removes from host list', () => {
        const priorityUrl = services.get(testUrlTemplate.name, true);
        const originalServiceUrlHostLength = testUrl.hosts.length;

        services.markFailedUrl(priorityUrl);

        assert.isBelow(testUrl.hosts.length, originalServiceUrlHostLength);
      });

      it('returns the next priority url', () => {
        const priorityUrl = services.get(testUrlTemplate.name, true);

        const nextPriorityUrl = services.markFailedUrl(priorityUrl);

        assert.notEqual(priorityUrl, nextPriorityUrl);
      });

      afterEach('unload test url', () => {
        services._unloadServiceUrls('Limited', [testUrl]);
      });
    });

    describe('#updateServices()', () => {
      it('returns a Promise that resolves to a list of services', (done) => {
        const servicesPromise = services.updateServices();

        assert.typeOf(servicesPromise, 'Promise');

        servicesPromise.then((serviceList) => {
          Object.keys(serviceList).forEach((key) => {
            assert.typeOf(key, 'string');
            assert.typeOf(serviceList[key], 'string');
          });

          done();
        });
      });

      it('triggers servicesUpdated', (done) => {
        services.once('servicesUpdated', () => {
          done();
        });

        services.updateServices();
      });

      it('updates the services list', (done) => {
        services._serviceUrls = [];

        services.once('servicesUpdated', () => {
          assert.isAbove(services._serviceUrls.length, 0);
          done();
        });

        services.updateServices();
      });

      it('updates the limited catalog when email is provided', (done) => {
        services._serviceUrlsLimited = [];

        services.updateServices('email', webexUser.email)
          .then(() => {
            assert.isAbove(services._serviceUrlsLimited.length, 0);
            done();
          });
      });

      it('updates the limited catalog when userId is provided', (done) => {
        services._serviceUrlsLimited = [];

        services.updateServices('userId', webexUser.id)
          .then(() => {
            assert.isAbove(services._serviceUrlsLimited.length, 0);
            done();
          });
      });

      it('updates the limited catalog when orgId is provided', (done) => {
        services._serviceUrlsLimited = [];

        services.updateServices('orgId', webexUser.orgId)
          .then(() => {
            assert.isAbove(services._serviceUrlsLimited.length, 0);
            done();
          });
      });
    });

    describe('#_loadServiceUrls()', () => {
      let testUrlTemplate;
      let testUrl;

      beforeEach('init test url', () => {
        testUrlTemplate = {
          defaultUrl: 'https://www.example.com/api/v1',
          hosts: [],
          name: 'exampleValid'
        };
        testUrl = new ServiceUrl({...testUrlTemplate});
      });

      it('appends services to different service groups', () => {
        services._loadServiceUrls('', [testUrl]);
        services._loadServiceUrls('Limited', [testUrl]);
        services._loadServiceUrls('Discovery', [testUrl]);

        services._serviceUrls.includes(testUrl);
        services._serviceUrls.includes(testUrl);
        services._serviceUrls.includes(testUrl);

        services._unloadServiceUrls('', [testUrl]);
        services._unloadServiceUrls('Limited', [testUrl]);
        services._unloadServiceUrls('Discovery', [testUrl]);
      });
    });

    describe('#_unloadServiceUrls()', () => {
      let testUrlTemplate;
      let testUrl;

      beforeEach('init test url', () => {
        testUrlTemplate = {
          defaultUrl: 'https://www.example.com/api/v1',
          hosts: [],
          name: 'exampleValid'
        };
        testUrl = new ServiceUrl({...testUrlTemplate});
      });

      it('appends services to different service groups', () => {
        services._loadServiceUrls('', [testUrl]);
        services._loadServiceUrls('Limited', [testUrl]);
        services._loadServiceUrls('Discovery', [testUrl]);

        const oBaseLength = services._serviceUrls.length;
        const oLimitedLength = services._serviceUrlsLimited.length;
        const oDiscoveryLength = services._serviceUrlsDiscovery.length;

        services._unloadServiceUrls('', [testUrl]);
        services._unloadServiceUrls('Limited', [testUrl]);
        services._unloadServiceUrls('Discovery', [testUrl]);

        assert.isAbove(oBaseLength, services._serviceUrls.length);
        assert.isAbove(oLimitedLength, services._serviceUrlsLimited.length);
        assert.isAbove(oDiscoveryLength, services._serviceUrlsDiscovery.length);
      });
    });

    describe('#_updateServiceUrls()', () => {
      let testCatalog;
      let testHostmap;

      beforeEach('load test url', () => {
        testCatalog = {
          serviceLinks: {
            'example-a': 'https://example-a.com/api/v1',
            'example-b': 'https://example-b.com/api/v1',
            'example-c': 'https://example-c.com/api/v1'
          },
          hostCatalog: {
            'example-a.com': [
              {host: 'example-a-1.com', ttl: -1, priority: 5},
              {host: 'example-a-2.com', ttl: -1, priority: 3},
              {host: 'example-a-3.com', ttl: -1, priority: 1}
            ],
            'example-b.com': [
              {host: 'example-b-1.com', ttl: -1, priority: 5},
              {host: 'example-b-2.com', ttl: -1, priority: 3},
              {host: 'example-b-3.com', ttl: -1, priority: 1}
            ],
            'example-c.com': [
              {host: 'example-c-1.com', ttl: -1, priority: 5},
              {host: 'example-c-2.com', ttl: -1, priority: 3},
              {host: 'example-c-3.com', ttl: -1, priority: 1}
            ]
          },
          format: 'hostmap'
        };
        testHostmap = services._formatReceivedHostmap(testCatalog);
      });

      it('removes any unused urls from current services', () => {
        const originalLength = services._serviceUrls.length;

        services._updateServiceUrls([]);

        assert.isBelow(services._serviceUrls.length, originalLength);
      });

      it('updates the target catalog to contain the provided hosts', () => {
        services._updateServiceUrls(testHostmap, 'Limited');

        assert.equal(services._serviceUrlsLimited.length, testHostmap.length);
      });

      it('updates any existing ServiceUrls', () => {
        const newTestCatalog = {...testCatalog};

        newTestCatalog.serviceLinks['example-a'] = 'https://e-a.com/api/v1';
        newTestCatalog.serviceLinks['example-b'] = 'https://e-b.com/api/v1';
        newTestCatalog.serviceLinks['example-c'] = 'https://e-c.com/api/v1';
        newTestCatalog.hostCatalog['example-a'] = [];
        newTestCatalog.hostCatalog['example-b'] = [];
        newTestCatalog.hostCatalog['example-c'] = [];

        const newHostMap = services._formatReceivedHostmap(newTestCatalog);

        services._updateServiceUrls(testHostmap, 'Limited');

        const oServicesB = services.services(false, 'Limited');
        const oServicesH = services.services(true, 'Limited');

        services._updateServiceUrls(newHostMap, 'Limited');

        const nServicesB = services.services(false, 'Limited');
        const nServicesH = services.services(true, 'Limited');

        Object.keys(nServicesB).forEach((key) => {
          assert.notEqual(nServicesB[key], oServicesB[key]);
        });

        Object.keys(nServicesH).forEach((key) => {
          assert.notEqual(nServicesH[key], oServicesH[key]);
        });
      });
    });

    describe('#_fetchNewServiceHostmap()', () => {
      let fullRemoteHM;
      let limitedRemoteHM;

      beforeEach(() => Promise.all([
        services._fetchNewServiceHostmap(),
        services._fetchNewServiceHostmap(true, 'userId', webexUser.id)
      ])
        .then(([fRHM, lRHM]) => {
          fullRemoteHM = fRHM;
          limitedRemoteHM = lRHM;

          return Promise.resolve();
        }));

      it('returns a promise', () => {
        assert.typeOf(services._fetchNewServiceHostmap(), 'Promise');
      });

      it('resolves to an authed u2c hostmap when no params specified', () => {
        assert.typeOf(fullRemoteHM, 'array');
        assert.isAbove(fullRemoteHM.length, 0);
      });

      it('resolves to a limited u2c hostmap when params specified', () => {
        assert.typeOf(limitedRemoteHM, 'array');
        assert.isAbove(limitedRemoteHM.length, 0);
      });

      it('rejects if the params provided are invalid', () => (
        services._fetchNewServiceHostmap(true, 'userId', 'notValid')
          .then(() => {
            assert.isTrue(false, 'should have rejected');

            return Promise.reject();
          })
          .catch((e) => {
            assert.typeOf(e, 'Error');

            return Promise.resolve();
          })
      ));
    });
  });
});
/* eslint-enable no-underscore-dangle */
